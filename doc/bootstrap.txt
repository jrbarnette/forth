bootstrapping design, revisited
    conclusion:
    ... oh, poot, let's just build a complete new interpreter
        inside the existing interpreter
    ... outer interpreter can be Forth, with random selections
	from ANS as needed, plus a few custom bits
    ... let's build the interpret/compile duality concept, 'cause
	that's what I like
    rationale:
    ... we just want QUIT in Forth to simplify construction
	of an interpreter without vestiges
    ... building QUIT requires sophisticated code that knows
	a lot about the dictionary
    ... we want that sophistication in Forth, not C
    ... a stripped-down interpreter that we build up is a
	lot of special code
    ... and complicated, with syntactic nuisances

really, want an interpreter with QUIT implemented in FORTH
... or rather, implemented with threaded code
... an executable with vestiges of the C coded bootstrap is OK

Then, use the interpreter to build one or more compilation targets
... that doesn't have the vestiges

bootstrap.meta is a useful starting point
... but the syntax is too awkward
... and the code isn't reusable
... well, wait, reusing the bootstrap isn't the point
... but, closer to Forth is more likely to be reusable
... something that interprets a string
... doesn't have to be Forth at all
... this is back to the not-quite-forth interpreter idea

what do we need?
equivalents to the special primitives (sort of, maybe...):
    init_dictionary
    init_names
    i_comma
    i_call
    i_addname
    i_setflags
    interpret_names
    i_literal

a mapping of names to primitive functions
start with an empty FORTH dictionary
need primitives that understand the dictionary
    maybe HERE and FORTH-WORDLIST known to bootstrap
	know how to add data and names
    maybe know how to look up names (e.g SEARCH-WORDLIST)
    want to execute code we build in the dictionary
	... which means knowing the format of names
	... and knowing FORTH-WORDLIST
    meta mode needs these things:
	look up definitions
	execute from XT
	compile XT to dictionary
	compile literal to dictionary


modes of operation:
    direct - look up name in mapping, execute the function
    primitives needed in direct mode
	any standard Forth word implemented in C
	    can just execute it
	    or, put the C handler on the stack
	primitives known to compilation/creation words
	    do_skip do_fskip
	    do_colon do_constant
	    do_variable do_literal
	    do_plus_loop, etc.
	    do_s_quote do_c_quote
	direct mode only primitives
	    ' - fetch C handler for name that follows
	    stuff to allocate names
	    here allot align , c,
	    immediate no-interpret compile-only
	    forth-wordlist
    meta -
	look up name in dictionary
	if found it
	    if interpret
		execute
	    else
		compile to dictionary
	else
	    try number
	    if parsed
		if interpret
		    push to stack
		else
		    compile literal
    meta is just QUIT in C

For all this stuff to be _useful_, it needs to know stuff
about the dictionary we're building.
... lots of stuff
... but we don't want that knowledge embedded in C
... and it stll looks a lot like a real Forth interpreter
... 'cause if it's in Forth, we can re-use the code to build the
    final interpreter
