immediate word:  a Forth word whose compilation semantics are to
    perform its execution semantics.
default interpretation semantics are execution semantics
default compilation semantics are to append execution semantics

Assume this dictionary entry layout:
    link
    count char, name char*len
    interpret xt
    compile xt
    handler, data ...

Assume we're in QUIT, and a valid name has been found.  To handle,
we convert the name to point to the interpret xt, field, then do
this:
    DUP STATE @ CELLS - @ EXECUTE

That implies various configurations for "compile xt" and "interpret
xt".

standard definition
    compile -> COMPILE,
    interpret -> EXECUTE

immediate definition
    compile -> EXECUTE
    interpret -> EXECUTE

no-interpret definition
    compile -> COMPILE,
    interpret -> -14 THROW

compile-only definition
    compile -> EXECUTE
    interpret -> -14 THROW

constant definition
    compile -> EXECUTE POSTPONE LITERAL
    interpret -> EXECUTE

variable definition
    compile -> EXECUTE POSTPONE LITERAL
    interpret -> EXECUTE

Note that for the interpret XT, the only available options are these:
    EXECUTE
    -14 THROW

So, we could instead use a flag in the name's count char, providing
us with this layout:
    link
    count char | flag, name char*len
    compile xt
    handler, data ...

Then QUIT would do this
    ( compile-ptr flag )
    STATE @ IF
        DROP DUP CELL+ SWAP @ EXECUTE
    ELSE
        IF -14 THROW ELSE CELL+ EXECUTE THEN
    THEN

But then we lose the ability to customize.  One interesting customization
would be that we could implement CREATE to get rid of a separate
DOES> pointer.

First, change QUIT behavior to be this:
    DUP CELL+ SWAP STATE @ CELLS - @ EXECUTE

So, both interpret and compile XTs would see the interpret pointer
at TOS.  That implies the following behavior configurations:

standard definition
    compile -> CELL+ COMPILE,
    interpret -> CELL+ EXECUTE

immediate definition
    compile -> CELL+ EXECUTE
    interpret -> CELL+ EXECUTE

no-interpret definition
    compile -> CELL+ COMPILE,
    interpret -> -14 THROW

compile-only definition
    compile -> CELL+ EXECUTE
    interpret -> -14 THROW

CONSTANT definition
    compile -> CELL+ @ POSTPONE LITERAL
    ... or -> DUP @ EXECUTE POSTPONE LITERAL
    interpret -> CELL+ @

VARIABLE definition
    compile -> CELL+ POSTPONE LITERAL
    ... or -> DUP @ EXECUTE POSTPONE LITERAL
    interpret -> CELL+

CREATE definition:
    compile -> CELL+ POSTPONE LITERAL @ COMPILE,
    interpret -> CELL+ SWAP @ EXECUTE

CREATE IMMEDIATE definition:
    compile -> CELL+ SWAP @ EXECUTE
    interpret -> CELL+ SWAP @ EXECUTE

We could create a magic xt for CONSTANT and VARIABLE such that
COMPILE, would skip it (e.g. a well-known NOP xt).  A well-known
NOP would also be useful to allow CHARS to compile to nothing.
Then CONSTANT and VARIABLE would be the famous
    : CONSTANT CREATE , DOES> @ ;
    : VARIABLE CREATE 0 , ;

----
It could be that the xt returned by ' et al. should be the
pointer to the (interpret, compile) pair in the definition.
Then we'd to have COMPILE, and EXECUTE be special.  (How?)
