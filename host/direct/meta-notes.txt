vocabularies
HOST
    stuff to be shared between DIRECT-MODE and META-MODE
DIRECT
    stuff that must be unique to DIRECT-MODE
	... typically emit stuff to execute specific functions:
	{ .handler = x_dup },
META
    only things defined in the the target dictionary
	... typically just emit the name of the definition:
	{ .str = "DUP" },
	... may be specially implemented

maybe need some special vocabularies:
  + In meta mode, certain words sometimes shadow entries in the
    target dictionary:
	[ ]
	: CONSTANT CREATE VARIABLE
  + Shadowing rules are tricky:
      - Most of the time, shadow in meta-compile or for POSTPONE
	only.
      - For [, shadow for POSTPONE only.

compilation modes:  direct, meta-interpret, meta-compile
    separate state settings for interpreter (front-end) and
    generation (back-end).
      + interpreter mode determines behavior of parsed names
      + backend mode tracks whether to issue one of the following:
	    { .str = NULL },			// end either meta mode
	    { .handler = meta_interpret },	// begin meta-interpret
	    { .handler = meta_compile },	// begin meta-compile

"mode" is determined by "meta-state @"
    0 meta-state !	\ direct
    1 meta-state !	\ meta-interpret
    2 meta-state !	\ meta-compile

front-end state actions
 mode | I | C | action
   D  | X | F | META-EXECUTE
   D  | X | T | error
   I  | X | F | META-EXECUTE
   I  | X | T | error
   C  | F | X | META-EXECUTE
   C  | T | X | 1 meta-next ! META-EXECUTE

use this
    : META-EXECUTE ( xt -- i*x ) EXECUTE meta-state @ meta-next ! ;

need 3 meta state variables
    meta-state \ assign this to meta-next after each word
    meta-next \ mode for next next dict cell emitted
    meta-emit \ mode as of last dict cell emitted

Full logic for identifiers
    ( xt flags )
    meta-state @ 2 and if
	\ meta-compile
	nf-immediate and if 1 meta-next ! then execute
    else
	\ meta-interpret or direct
	nf-compile-only and if -14 throw else execute then
    then meta-state @ meta-next !

backend state action table for mode change (before -> after)
 prev | next | emit
   D  |   I  | { .handler = meta_interpret },
   D  |   C  | { .handler = meta_compile },
   I  |   D  | { .id = NULL },
   I  |   C  | { .id = NULL }, { .handler = meta_compile },
   C  |   D  | { .id = NULL },
   C  |   I  | { .id = NULL }, { .handler = meta_interpret },

Full logic
    meta-next @
    dup meta-emit @ <> if
	meta-emit @ if { ." .id = NULL" } then
	dup meta-emit !
	?dup if
	    { 1- if s" meta_compile" else s" meta_interpret" then .exec }
	then
    then

consider these:
    : D{ 0 meta-next ! { ;
    : I{ 1 meta-next ! { ;
    : C{ 2 meta-next ! { ;
    : I" postpone I{ postpone S" postpone .str postpone } ; immediate
    : C" postpone C{ postpone S" postpone .str postpone } ; immediate
can we use these to get rid of meta-next?
... but definitions in meta vocabulary don't know whether to use
    "I" or "C".


Full logic for literals
    ( x )
    D{ s" do_literal" .exec }{ c-hex .cell }
    meta-state @ 2 = if
	\ <HOST> ] LITERAL
	\ I" LITERAL"
	I{ s" LITERAL" .str }
    then

POSTPONE
    \ lookup name in META vocabulary
    ( xt flags )
    nf-immediate and if
	2 meta-next !
    else
	\ [COMPILE] LITERAL ['] COMPILE, COMPILE,
	\ this is not yet right
	0 meta-next ! { s" i_compile" .exec }
    then execute

utility words:
<HOST>
    ONLY FORTH ALSO HOST DEFINITIONS
    : <HOST> ONLY FORTH ALSO HOST ;
<C> ...;
    (in HOST vocabulary, at least for now)
    C expression as { .cell = (cell_ft)(...) },
<DIRECT>
    <HOST> DEFINITIONS
    : <DIRECT> 0 meta-state ! ONLY HOST ALSO DIRECT ;
[
    <HOST> DEFINITIONS
    : [ 1 meta-state ! ONLY HOST ALSO META ; IMMEDIATE
]
    <HOST> DEFINITIONS
    : ] 2 meta-state ! ONLY HOST ALSO META ;

vocabulary HOST
vocabulary DIRECT
vocabulary META

0
variable meta-state  dup meta-state !
variable meta-next   dup meta-next !
variable meta-prev   dup meta-prev !
drop

only forth also host definitions
: <HOST> only forth also host ;
: <DIRECT> 0 meta-state ! only host also direct ;
: <META> meta-state ! only meta also host ;
: [ 1 <META> ; immediate
: ] 2 <META> ;

====
To execute code in meta interpretation state:
    { .handler = meta_interpret },
	{ .str = "..." }, ...
	{ .str = NULL },

To compile tokens into the dictionary:
    { .handler = meta_compile },
	{ .str = "..." }, ...
	{ .str = NULL },

-1 constant TRUE
    { .handler = do_literal }, { .cell = -1 },
    { .handler = i_addname }, { .str = "TRUE" }, { .handler = do_constant },
    { .handler = i_linkname },

: CHARS ;
    { .handler = i_addname }, { .str = "CHARS" }, { .handler = do_colon },
    { .handler = meta_compile },
	{ .str = "EXIT" },
	{ .str = NULL },
    { .handler = i_linkname },

: CELLS <C> CELL_SIZE; * ;
    { .handler = i_addname }, { .str = "CELLS" }, { .handler = do_colon },
    { .handler = do_literal }, { .cell = CELL_SIZE },
    { .handler = meta_interpret },
	{ .str = "LITERAL" },
	{ .str = NULL },
    { .handler = meta_compile },
	{ .str = "LITERAL" },
	{ .str = "*" },
	{ .str = "EXIT" },
	{ .str = NULL },
    { .handler = i_linkname },

handling for IMMEDIATE words
: >BODY ( xt -- a-addr ) [ 2 cells ] literal + ;
    { .handler = i_addname }, { .str = ">BODY" }, { .handler = do_colon },
    // : leaves us in meta-compile state
    // then [ triggers meta-interpret
    // then interpreter triggers direct mode for number literal
    { .handler = do_literal }, { .cell = 2 },
    // then interpreter returns to meta-interpret
    { .handler = meta_interpret },
	{ .str = "CELLS" },
	// ] triggers return to meta-compile
	// interpreter triggers meta-interpret for immediate LITERAL
	{ .str = "LITERAL" },
	// then interpreter returns to meta-compile
	{ .str = NULL },
    { .handler = meta_compile },
	{ .str = "+" },
	{ .str = "EXIT" },
	{ .str = NULL },
    { .handler = i_linkname },

handling for POSTPONE
: [CHAR] char postpone literal ; compile-only
    { .handler = i_addname }, { .str = "[CHAR]" }, { .handler = do_colon },
    { .handler = meta_compile },
	{ .str = "CHAR" },
	// POSTPONE emits LITERAL in meta-compile
	{ .str = "LITERAL" },
	{ .str = "EXIT" },
	{ .str = NULL },
    { .handler = i_linkname },
    { .handler = meta_interpret },
	{ .str = "COMPILE-ONLY" },
	{ .str = NULL },

====
number literals:
    direct:
	// literal
	{ .handler = do_literal }, { .cell = <number value> },
    interpret:  wrap direct-mode semantics
	// <DIRECT>
	    { .str = NULL },
	// literal
	{ .handler = do_literal }, { .cell = <number value> },
	// [
	// this will be triggered at next generation action
	{ .handler = meta_interpret },
    compile:
	// <DIRECT> literal
	    { .str = NULL },
	{ .handler = do_literal }, { .cell = <number value> },
	// ] LITERAL
	{ .handler = meta_interpret },
	    { .str = "LITERAL" },
	// this will be triggered at next generation action
	    { .str = NULL },
	{ .handler = meta_compile },

primitives - default semantics:
    definition:
	// prim: <Forth name> <C handler>
	{ .handler = i_addname },
	    { .str = <Forth name> }, { .handler = <C handler> },
    direct:
	{ .handler = <handler> },
    interpret:
	// [
	{ .str = <Forth name> },
    compile:
	// ]
	{ .str = <Forth name> },
    postpone:
	// <DIRECT>
	    { .str = NULL },
	{ .handler = i_lookup }, { .str = <Forth name> },
	// ] LITERAL
	{ .handler = meta_interpret },
	    { .str = "LITERAL" },
	    { .str = NULL },
	{ .handler = meta_compile },
	    { .str = "," },	// really "COMPILE,"
    implementation:
      + DIRECT vocabulary implements direct semantics
      + META vocabulary has a word created with something like this:
	    : meta-def
		here create name>id here 2 cells allot 2!
		does> { 2@ .str } ;
      + COMPILE-INPUT keeps track of meta-state so that meta
	interpretation and compilation are distinguished.


definitions with "no-interpret" semantics:
    definition:
	// ... definition
	{ .handler = i_setflags }, { .cell = 0x40 },
    direct:      error
    interpret:   error
    implementation:
      + DIRECT vocabulary has no such words
      + META vocabulary flags indicate usage

immediate definitions semantics:
    definition:
	// ... definition
	{ .handler = i_setflags }, { .cell = 0x80 },
    compile:
	// [
	    { .str = NULL },
	{ .handler = meta_interpret },
	    { .str = <Forth name> },
	// ]
	    { .str = NULL },
	{ .handler = meta_compile },
    postpone:
	// in meta-compile mode
	    { .str = <Forth name> },
    implementation:
      + Compile and interpret behaviors are intrinsic to the compilation
	interpreter
      + POSTPONE executes this:
	    2 meta-state ! EXECUTE

IMMEDIATE             6.1.1710 CORE                   40
COMPILE-ONLY          (non-standard)
    direct:
	// IMMEDIATE
	{ .handler = i_setflags }, { .cell = 0x80 },
	// COMPILE-ONLY
	{ .handler = i_setflags }, { .cell = 0x40 },
    interpret:   wrap direct mode semantics
    implementation:
      + Put these words in the HOST vocabulary

any definition that calls PARSE:
    definition:  may be re-implemented for direct mode
    direct:      error if not re-implemented for this mode
    interpret:   wrap direct-mode semantics
    compile:    default compilation semantics
    implementation:
      + Put re-implementation (if any) in the HOST vocabulary
      + Compilation handling TBD

certain definitions like ]:
    direct:     custom non-error handling
    interpret:  custom non-error handling
    compile:    default compilation semantics
    implementation:
      + Put in the HOST vocabulary
      + Compilation handling TBD

CONSTANT              6.1.0950 CORE                   35
    definition:
	// <calculate value>
	// CONSTANT <Forth name>
	// Option A) for right now
	{ .handler = i_addname },
	    { .str = <Forth name> }, { .handler = do_constant },
	{ .handler = x_comma },
	// Option B) consider for later
	// <DIRECT>
	{ .handler = i_addname },
	    { .str = <Forth name> }, { .handler = do_constant },
	// [ ,
	{ .handler = meta_interpret },
	    { .str = "," },
    direct:
	{ .handler = do_literal }, { .cell = <value from definition> },
    implementation:
      + Put option A) in the HOST vocabulary.  Create the name in the
	META vocabulary with meta-def (from above).
      + Don't allow definining/using constants in direct mode for now.
	(Or else, force dual definition?)

VARIABLE              6.1.2410 CORE                   48
    definition:
	// VARIABLE <Forth name>
	// Option A) for right now
	{ .handler = i_addname },
	    { .str = <Forth name> }, { .handler = do_variable },
	    { .cell = 0 },
	// Option B) available in meta-interpret mode
	// <DIRECT>
	{ .handler = i_addname },
	    { .str = <Forth name> }, { .handler = do_variable },
	// [ 1 cells allot
	{ .handler = do_literal }, { .cell = 1 },
	{ .handler = meta_interpret },
	    { .str = "CELLS" },
	    { .str = "ALLOT" },
    direct:     error
    implementation:
      + Put option A) in the HOST vocabulary.
      + Create the name in the META vocabulary with meta-def (from
	above).

CREATE                6.1.1000 CORE                   36
    definition:  default semantics for definitions that call PARSE

:                     6.1.0450 CORE                   30
    definition:
	// : <Forth name>
	{ .handler = i_startname },
	    { .str = <Forth name> }, { .handler = do_colon },
	// ]
	// this may be triggered at next generation action
	{ .handler = meta_compile },
    direct:     error
    implementation:
      + Put this in the HOST vocabulary.
      + Create the name in the META vocabulary with meta-def (from
	above).

;                     6.1.0460 CORE                   30
    direct:     error
    interpret:  error
    compile:
	// POSTPONE EXIT
	    { .str = "EXIT" },
	// [
	// this will be triggered at next generation action
	    { .str = NULL },
	{ .handler = i_linkname },
	// this may be triggered at next generation action
	{ .handler = meta_interpret },
    implementation:
      + Put this in the META vocabulary as an immediate,
	compile-only word.

]                     6.1.2540 CORE                   49
    direct:     switch to meta-compile mode
    interpret:  switch to meta-compile mode
    compile:    default semantics, i.e.
	{ .str = "]" },
    implementation:
      + TBD

[                     6.1.2500 CORE                   48
    direct:     switch to meta-interpret mode
    interpret:  switch to meta-interpret mode (no-op)
    compile:    switch to meta-interpret mode
    implementation:
      + Put this in the HOST vocabulary as an immediate word.
      + POSTPONE handling TBD


BASE                  6.1.0750 CORE                   34
    must execute with something like <HOST> BASE

DECIMAL               6.1.1170 CORE                   36
HEX                   6.2.1660 CORE EXT               54
    direct:     can execute host semantics
    implementation:
      + Create an alias in the DIRECT vocabulary

(                     6.1.0080 CORE                   26
.(                    6.2.0200 CORE EXT               49
\                     6.2.2535 CORE EXT               58
    direct:     execute host semantics
    interpret:  execute host semantics
    compile:    execute host semantics
    postpone:   compile target semantics
    implementation:
      + TBD - same problem as [ and ] and parsing words

'                     6.1.0070 CORE                   25
CHAR                  6.1.0895 CORE                   35
    implementation:
      + these call PARSE; don't re-implement (for now)

POSTPONE              6.1.2033 CORE                   43
    direct:     error
    interpret:  error
    compile:    wrap custom direct mode code
    postpone:   error
    implementation:
      + Put this in the META vocabulary as an immediate,
	compile-only word.

."                    6.1.0190 CORE                   28
S"                    6.1.2165 CORE                   44
[']                   6.1.2510 CORE                   50
[CHAR]                6.1.2520 CORE                   50
[COMPILE]             6.2.2530 CORE EXT               60
    direct:     error
    interpret:  error
    compile:    wrap custom direct mode code
    postpone    compile target semantics
    implementation:
      + Put this in the META vocabulary as an immediate,
	compile-only word.
      + POSTPONE TBD

(can omit these)
:NONAME               6.2.0455 CORE EXT               52
MARKER                6.2.1850 CORE EXT               56
TO                    6.2.2295 CORE EXT               59
VALUE                 6.2.2405 CORE EXT               60

parsing words:
    : CONSTANT CREATE VARIABLE
    MARKER TO VALUE
    ' CHAR
    POSTPONE S" ['] [CHAR] [COMPILE]

compilation-special words:
    ( .( \
    [ ] ;
    LITERAL
    S" ['] [CHAR]
    POSTPONE [COMPILE]
    ."
    IF ELSE THEN
    BEGIN WHILE REPEAT UNTIL AGAIN
    DO I J LEAVE UNLOOP LOOP +LOOP
    DOES>

host words:
    BASE HEX DECIMAL

====
'                     6.1.0070 CORE                   25
(                     6.1.0080 CORE                   26
."                    6.1.0190 CORE                   28
:                     6.1.0450 CORE                   30
;                     6.1.0460 CORE                   30
BASE                  6.1.0750 CORE                   34
CHAR                  6.1.0895 CORE                   35
CONSTANT              6.1.0950 CORE                   35
CREATE                6.1.1000 CORE                   36
DECIMAL               6.1.1170 CORE                   36
IMMEDIATE             6.1.1710 CORE                   40
POSTPONE              6.1.2033 CORE                   43
S"                    6.1.2165 CORE                   44
VARIABLE              6.1.2410 CORE                   48
[                     6.1.2500 CORE                   48
[']                   6.1.2510 CORE                   50
[CHAR]                6.1.2520 CORE                   50
]                     6.1.2540 CORE                   49
.(                    6.2.0200 CORE EXT               49
:NONAME               6.2.0455 CORE EXT               52
HEX                   6.2.1660 CORE EXT               54
MARKER                6.2.1850 CORE EXT               56
TO                    6.2.2295 CORE EXT               59
VALUE                 6.2.2405 CORE EXT               60
[COMPILE]             6.2.2530 CORE EXT               60
\                     6.2.2535 CORE EXT               58
COMPILE-ONLY          (non-standard)
